import * as AS from "../index";

const s1 = AS.MakeStorage(AS.StorageKind.Memory, null, "s1");

(async function () { 
	const t = AS.Task<string>()
		.tokenize()
		.print(1)
		.each()
		.print(2)
		.fn(x => x.length)
		.print(4)
		.fn(x => [x, 1, 2, 3, 4, "abcd"])
		.print(4)
		.map(x => x.toString())
		.print(5)
		.filterArray(x => x.length < 2)
		.print(6)
		.flat()
		.print(7)
		.reduce(x => parseInt(x))
		.print(8)
		.fn(x => [x, 1, 2, 2, 3, 4, "abcd"])
		.print(9)
		.countInArray(x => x)
		.print(10)
		.fn(x => Object.values(x))
		.print(11)
		.flat()
		.print(12)
		.withLocalKVStorage<number>()
		.setLocalKV("k1", x => x[0] + 10)
		.print(13)
		.getLocalKV("k1")
		.print(14)
		.setLocalKVRaw("k2", r => parseInt(r.key as string))
		.flushLocalKV("k1")
		.getLocalKV("k1")
		.print(15)
		.fn(_ => 100)
		.print(16)
		.getLocalKV("k2")
		.print(17)
		.fn(x => ({ prop: x }))
		.mergeLocalKV("k2")
		.print(18)
		.withStorage(s1)
		.toStorage(_ => "sk1", x => "bla")
		.fn(async _ => []) // check promise infer
		.fnRaw(async _ => [])//from storage pushes in array
		.fromStorage(_ => ["sk1"])
		.fn(x => { console.log(19, x); return x })
		.fromStorageToGlobalState(_ => ["sk1"])
		.fnRaw(x => { console.log(20, x); return x })
		.toStorageList(_ => "skl1", x => x, 100)
		.fromStorageList(_ => ["skl1"], x => [])
		.fn(x => { console.log(21, x); return x })
		.flushStorage(x => ["skl1"])
		.fromStorageList(_ => ["skl1"], x => [])
		.print(22)
		.disconnectStorage()
		.fn(x => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
		.groupBy(x => x % 2 === 0 
			? "even"
			: "odd"
		)
		.print(23)


	await t.inject("i tipi sono belli e mi fanno sentire pi√π sicuro, anche con javascript")
})()
